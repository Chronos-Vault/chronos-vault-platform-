/**
 * ChronosVault.fc - TON Smart Contract for ChronosVault Platform
 * 
 * This contract implements a time-locked vault for digital assets
 * with advanced security features and cross-chain integration.
 */

#include "imports/stdlib.fc";

;; Storage structure
;; storage#_ owner:MsgAddress
;;           unlock_time:uint64
;;           content:^Cell  
;;           access_key:uint256
;;           security_level:uint8
;;           chain_data:^Cell
;;           = Storage;

(slice, int, cell, int, int, cell) load_data() inline {
  var ds = get_data().begin_parse();
  return (
    ds~load_msg_addr(),    ;; owner address
    ds~load_uint(64),      ;; unlock_time
    ds~load_ref(),         ;; content
    ds~load_uint(256),     ;; access key (for advanced auth)
    ds~load_uint(8),       ;; security level
    ds~load_ref()          ;; chain_data (cross-chain information)
  );
}

() save_data(slice owner, int unlock_time, cell content, int access_key, int security_level, cell chain_data) impure inline {
  set_data(begin_cell()
    .store_slice(owner)
    .store_uint(unlock_time, 64)
    .store_ref(content)
    .store_uint(access_key, 256)
    .store_uint(security_level, 8)
    .store_ref(chain_data)
    .end_cell());
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
  slice cs = in_msg_cell.begin_parse();
  int flags = cs~load_uint(4); ;; int_msg_info$0 flags
  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }

  slice sender = cs~load_msg_addr();
  (slice owner, int unlock_time, cell content, int access_key, int security_level, cell chain_data) = load_data();
  
  ;; Get operation code
  int op = in_msg~load_uint(32);
  
  ;; Op code handling
  if (op == 0x1) { ;; get vault data
    if (equal_slices(sender, owner)) {
      send_raw_message(begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(content)
        .end_cell(), 64);
    }
    return ();
  }
  
  if (op == 0x2) { ;; update unlock time (only owner can do this)
    throw_unless(401, equal_slices(sender, owner));
    int new_unlock_time = in_msg~load_uint(64);
    save_data(owner, new_unlock_time, content, access_key, security_level, chain_data);
    return ();
  }
  
  if (op == 0x3) { ;; update security level (only owner can do this)
    throw_unless(401, equal_slices(sender, owner));
    int new_security_level = in_msg~load_uint(8);
    save_data(owner, unlock_time, content, access_key, new_security_level, chain_data);
    return ();
  }
  
  if (op == 0x4) { ;; update cross-chain data (only owner can do this)
    throw_unless(401, equal_slices(sender, owner));
    cell new_chain_data = in_msg~load_ref();
    save_data(owner, unlock_time, content, access_key, security_level, new_chain_data);
    return ();
  }
  
  if (op == 0x5) { ;; attempt to retrieve content
    int current_time = now();
    if (current_time >= unlock_time) {
      ;; Check if correct access key is provided for high security levels
      if (security_level > 1) {
        int provided_key = in_msg~load_uint(256);
        throw_unless(402, provided_key == access_key);
      }
      
      ;; Send the content to the requester
      send_raw_message(begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(content)
        .end_cell(), 64);
    } else {
      ;; Not yet unlocked
      throw(403);
    }
    return ();
  }
  
  throw(399); ;; Unknown operation
}

;; Get methods

(int) is_unlocked() method_id {
  (_, int unlock_time, _, _, _, _) = load_data();
  return now() >= unlock_time;
}

(int) get_unlock_time() method_id {
  (_, int unlock_time, _, _, _, _) = load_data();
  return unlock_time;
}

(cell) get_vault_data() method_id {
  (_, _, cell content, _, _, _) = load_data();
  return content;
}

(int) get_security_level() method_id {
  (_, _, _, _, int security_level, _) = load_data();
  return security_level;
}

(cell) get_verification_proof() method_id {
  (_, int unlock_time, _, _, int security_level, _) = load_data();
  
  ;; Generate a verification proof cell containing relevant vault information
  ;; This is used for cross-chain verification
  return begin_cell()
    .store_uint(now(), 64)
    .store_uint(unlock_time, 64)
    .store_uint(security_level, 8)
    .end_cell();
}

(cell) get_cross_chain_locations() method_id {
  (_, _, _, _, _, cell chain_data) = load_data();
  return chain_data;
}

(cell) get_vault_info() method_id {
  (slice owner, int unlock_time, _, _, int security_level, cell chain_data) = load_data();
  
  return begin_cell()
    .store_slice(owner)
    .store_uint(unlock_time, 64)
    .store_uint(security_level, 8)
    .store_uint(now(), 64)
    .store_uint(is_unlocked(), 1)
    .store_ref(chain_data)
    .end_cell();
}
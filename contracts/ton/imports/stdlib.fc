;; Standard library for FunC smart contracts
;; This file contains common utilities used across TON contracts

;; Data operations
() ~impure_touch() impure asm "NOP";

int null?(cell c) asm "ISNULL";
int cell_null?(cell c) asm "ISNULL";

builder store_maybe_ref(builder b, cell c) asm(c b) "STOPTREF";

int equal_slices(slice a, slice b) asm "SDEQ";
int builder_null?(builder b) asm "ISNULL";
builder store_builder(builder to, builder from) asm(from to) "STB";

;; Storage operations  
forall X -> (tuple, X) ~tpop(tuple t) asm "TPOP";

;; Message operations
int slice_bits(slice s) asm "SBITS";
int slice_refs(slice s) asm "SREFS";

;; Arithmetic
int muldiv(int a, int b, int c) asm "MULDIV";
int min(int x, int y) asm "MIN";
int max(int x, int y) asm "MAX";

;; Blockchain time
int now() asm "NOW";

;; Random number generation  
int random() asm "RANDU256";
int rand(int range) asm "RAND";

;; Hashing
int cell_hash(cell c) asm "HASHCU";
int slice_hash(slice s) asm "HASHSU";
int string_hash(slice s) asm "SHA256U";

;; Address helpers
int check_data_signature(slice data, slice signature, int public_key) asm "CHKSIGNU";
int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNS";

;; Serialization helpers
(slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
(slice, int) ~load_uint(slice s, int len) asm(s len -> 1 0) "LDUX";
builder store_int(builder b, int x, int len) asm(x b len) "STIX";
builder store_uint(builder b, int x, int len) asm(x b len) "STUX";

;; Dictionary operations  
cell new_dict() asm "NEWDICT";
(cell, int) ~udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF" "NULLSWAPIFNOT";
(cell, cell, int) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, cell, int) ~udict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGETREF";
(slice, int) ~udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";
(cell, slice, int) udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";

;; Tuple operations
forall X -> (tuple, X) ~tpop(tuple t) asm "TPOP";
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> X first(tuple t) asm "FIRST";
forall X -> X second(tuple t) asm "SECOND";
forall X -> X third(tuple t) asm "THIRD";
forall X -> X fourth(tuple t) asm "FOURTH";
tuple empty_tuple() asm "NIL";
int tuple_length(tuple t) asm "TLEN";

;; Slice operations
(slice, slice) load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";
builder store_slice(builder b, slice s) asm "STSLICER";
builder store_ref(builder b, cell c) asm(c b) "STREF";
cell preload_ref(slice s) asm "PLDREF";
(slice, cell) load_ref(slice s) asm( -> 1 0) "LDREF";
slice preload_bits(slice s, int len) asm "PLDSLICEX";
int slice_empty?(slice s) asm "SEMPTY";

;; Builder operations
builder begin_cell() asm "NEWC";
cell end_cell(builder b) asm "ENDC";
builder store_grams(builder b, int x) asm "STGRAMS";
builder store_coins(builder b, int x) asm "STGRAMS";
(slice, int) load_grams(slice s) asm( -> 1 0) "LDGRAMS";
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";

;; Message sending
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";

;; Storage
cell get_data() asm "c4 PUSH";
() set_data(cell c) impure asm "c4 POP";

;; Continuation
cont get_c3() impure asm "c3 PUSH";
() set_c3(cont c) impure asm "c3 POP";
cont bless(slice s) impure asm "BLESS";

;; Common
() throw(int exc_no) impure asm "THROW";
() throw_if(int exc_no, int cond) impure asm "THROWIF";
() throw_unless(int exc_no, int cond) impure asm "THROWIFNOT";

;; Gas
int gas_used() asm "GASCONSUMED";
int storage_fees() asm "STORAGEFEES";

;; Custom error messages
() throw_with_info(int error_code, slice info) impure {
    throw(error_code);
}
